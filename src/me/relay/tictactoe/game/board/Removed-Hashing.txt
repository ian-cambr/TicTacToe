Some stuff I wrote but didn't end up using as it was causing issues that were resolved when I just used the hashmap.
Leaving it here for posterity's sake.

/**
      * Here we use magic to generate a hash of the board.
      */
    @Override
    public int hashCode() {
        // We'll use an integer for speed.
        // Every 2 bits will represent a square.
        // 00 = NONE, 01 = X, 10 = O
        // NONE = 0, X = 1, O = 2
        // Ordinal should match up with the magic number.

        int hash = board[0][0].ordinal();
        for (BoardSymbol[] row : board) {
            for (BoardSymbol symbol : row) {
                hash = hash << 2 | symbol.ordinal();
            }
        }

        return hash;
    }

    /**
     * This is currently reconstructing in reverse order.
     * It doesn't really matter anyway; this was just for debugging
     * to confirm that the evaluations were equivalent.
     * The only thing that matters is that the hash is a unique and consistent representation of the board.
     */
    public static BoardState fromHash(int hash) {
        BoardState state = new BoardState();
        int mask = 3;

        for (int row = 0; row < 3; row++) {
            for (int col = 0; col < 3; col++) {
                int symbol = hash & mask;
                state.board[row][col] = BoardSymbol.values()[symbol];
                hash = hash >> 2;
            }
        }

        return state;
    }